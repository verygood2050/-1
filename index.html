<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ“– ì„±ê²½ ì•”ì†¡ ì¹´ë“œ</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Lucide ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ë“¤
    const Upload = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
      </svg>
    );

    const X = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const Download = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
      </svg>
    );

    const Search = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    );

    const BarChart3 = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
      </svg>
    );

    const Shuffle = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2h-2M8 20H6a2 2 0 01-2-2V6a2 2 0 012-2h2m8 0l4 4m0 0l-4 4m4-4H4" />
      </svg>
    );

    const RotateCcw = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
      </svg>
    );

    const BibleMemoryCards = () => {
      const generateEmptyData = () => {
        const data = {};
        data['001'] = {
          reference: 'ì°½ì„¸ê¸° 1:1,31',
          text: 'íƒœì´ˆì— í•˜ë‚˜ë‹˜ì´ ì²œì§€ë¥¼ ì°½ì¡°í•˜ì‹œë‹ˆë¼ í•˜ë‚˜ë‹˜ì´ ì§€ìœ¼ì‹  ê·¸ ëª¨ë“  ê²ƒì„ ë³´ì‹œë‹ˆ ë³´ì‹œê¸°ì— ì‹¬íˆ ì¢‹ì•˜ë”ë¼ ì €ë…ì´ ë˜ê³  ì•„ì¹¨ì´ ë˜ë‹ˆ ì´ëŠ” ì—¬ì„¯ì§¸ ë‚ ì´ë‹ˆë¼'
        };
        data['002'] = {
          reference: 'ì ì–¸ 16:9',
          text: 'ì‚¬ëŒì´ ë§ˆìŒìœ¼ë¡œ ìê¸°ì˜ ê¸¸ì„ ê³„íší• ì§€ë¼ë„ ê·¸ì˜ ê±¸ìŒì„ ì¸ë„í•˜ì‹œëŠ” ì´ëŠ” ì—¬í˜¸ì™€ì‹œë‹ˆë¼'
        };
        data['003'] = {
          reference: 'ìš”í•œë³µìŒ 13:34',
          text: 'ìƒˆ ê³„ëª…ì„ ë„ˆí¬ì—ê²Œ ì£¼ë…¸ë‹ˆ ì„œë¡œ ì‚¬ë‘í•˜ë¼ ë‚´ê°€ ë„ˆí¬ë¥¼ ì‚¬ë‘í•œ ê²ƒ ê°™ì´ ë„ˆí¬ë„ ì„œë¡œ ì‚¬ë‘í•˜ë¼'
        };
        return data;
      };

      const [verses, setVerses] = useState({});
      const [isLoading, setIsLoading] = useState(true);
      const [selectedCard, setSelectedCard] = useState('001');
      const [showUploadModal, setShowUploadModal] = useState(false);
      const [pasteText, setPasteText] = useState('');
      const [notification, setNotification] = useState('');
      const [counts, setCounts] = useState({});
      const [showAllCounts, setShowAllCounts] = useState(false);
      const [showAllVerses, setShowAllVerses] = useState(false);
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [showDeleteMenu, setShowDeleteMenu] = useState(false);
      const [showSearchModal, setShowSearchModal] = useState(false);
      const [searchQuery, setSearchQuery] = useState('');
      const [showStatsModal, setShowStatsModal] = useState(false);
      const [showQuizMode, setShowQuizMode] = useState(false);
      const [quizCard, setQuizCard] = useState(null);
      const [showQuizAnswer, setShowQuizAnswer] = useState(false);
      const [showResetCountModal, setShowResetCountModal] = useState(false);
      const [dailyHistory, setDailyHistory] = useState({});
      const [encouragementMsg, setEncouragementMsg] = useState('');
      const [showMultiDeleteModal, setShowMultiDeleteModal] = useState(false);
      const [selectedForDelete, setSelectedForDelete] = useState([]);
      const [showAddModal, setShowAddModal] = useState(false);
      const [showEditModal, setShowEditModal] = useState(false);
      const [newCardNumber, setNewCardNumber] = useState('');
      const [newCardReference, setNewCardReference] = useState('');
      const [newCardText, setNewCardText] = useState('');
      const [editCardReference, setEditCardReference] = useState('');
      const [editCardText, setEditCardText] = useState('');

      useEffect(() => {
        try {
          const savedVerses = localStorage.getItem('bibleVerses');
          const savedCounts = localStorage.getItem('bibleCounts');
          const savedHistory = localStorage.getItem('bibleHistory');
          
          if (savedVerses) {
            setVerses(JSON.parse(savedVerses));
          } else {
            const initialData = generateEmptyData();
            setVerses(initialData);
            localStorage.setItem('bibleVerses', JSON.stringify(initialData));
          }

          if (savedCounts) {
            setCounts(JSON.parse(savedCounts));
          }

          if (savedHistory) {
            setDailyHistory(JSON.parse(savedHistory));
          }
        } catch (error) {
          const initialData = generateEmptyData();
          setVerses(initialData);
        }
        setIsLoading(false);
      }, []);

      useEffect(() => {
        if (!isLoading && Object.keys(verses).length > 0) {
          localStorage.setItem('bibleVerses', JSON.stringify(verses));
        }
      }, [verses, isLoading]);

      useEffect(() => {
        if (!isLoading) {
          localStorage.setItem('bibleCounts', JSON.stringify(counts));
        }
      }, [counts, isLoading]);

      useEffect(() => {
        if (!isLoading) {
          localStorage.setItem('bibleHistory', JSON.stringify(dailyHistory));
        }
      }, [dailyHistory, isLoading]);

      const notify = (message, duration = 3000) => {
        setNotification(message);
        setTimeout(() => setNotification(''), duration);
      };

      const parseContent = (text) => {
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        const updates = {};
        let successCount = 0;
        const duplicates = [];

        lines.forEach(line => {
          if (line.includes('ë²ˆí˜¸') || line.includes('ì„±ê²½') || line.includes('ë³¸ë¬¸') || line.includes('êµ¬ì ˆ')) {
            return;
          }

          const normalized = line.replace(/[\s\t]+/g, ' ').trim();
          
          let pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+)\s+(.+?)\.?$/;
          let match = normalized.match(pattern);
          
          if (!match) {
            pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+\s*[-~]\s*\d+)\s+(.+?)\.?$/;
            match = normalized.match(pattern);
          }
          
          if (!match) {
            pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+\s*,\s*\d+)\s+(.+?)\.?$/;
            match = normalized.match(pattern);
          }
          
          if (!match) {
            pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+)$/;
            match = normalized.match(pattern);
            if (match) {
              match.push('(ë³¸ë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”)');
            }
          }
          
          if (!match) {
            pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+\s*[-~]\s*\d+)$/;
            match = normalized.match(pattern);
            if (match) {
              match.push('(ë³¸ë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”)');
            }
          }
          
          if (!match) {
            pattern = /^([A-E]0?\d{1,2}|\d{3})\s+([ê°€-í£\s]+?)\s+(\d+)\s*:\s*(\d+\s*,\s*\d+)$/;
            match = normalized.match(pattern);
            if (match) {
              match.push('(ë³¸ë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”)');
            }
          }
          
          if (match) {
            let cardKey = match[1].toUpperCase();
            const bookName = match[2].trim();
            const chapter = match[3];
            const verse = match[4].replace(/\s/g, '');
            const reference = `${bookName} ${chapter}:${verse}`;
            const verseText = match[5] ? match[5].trim() : '(ë³¸ë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”)';
            
            const existingCard = Object.entries(verses).find(([key, value]) => 
              value.reference === reference && key !== cardKey
            );
            
            if (existingCard) {
              duplicates.push(`${reference} (ê¸°ì¡´: ${existingCard[0]}, ì¶”ê°€ ì‹œë„: ${cardKey})`);
            } else {
              updates[cardKey] = {
                reference: reference,
                text: verseText
              };
              successCount++;
            }
          }
        });
        
        return { updates, successCount, duplicates };
      };

      const handlePasteSubmit = () => {
        if (!pasteText.trim()) {
          notify('âš ï¸ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }
        const { updates, successCount, duplicates } = parseContent(pasteText);
        
        if (duplicates.length > 0) {
          setVerses(prev => ({ ...prev, ...updates }));
          notify(`âš ï¸ ${successCount}ê°œ ì¶”ê°€, ${duplicates.length}ê°œ ì¤‘ë³µ ì œì™¸`, 3000);
          setTimeout(() => {
            setPasteText('');
            setShowUploadModal(false);
          }, 3000);
        } else if (successCount > 0) {
          setVerses(prev => ({ ...prev, ...updates }));
          notify(`âœ… ${successCount}ê°œì˜ ë§ì”€ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤`, 2000);
          setTimeout(() => {
            setPasteText('');
            setShowUploadModal(false);
          }, 2000);
        } else {
          notify('âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì˜ ë§ì”€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 3000);
        }
      };

      const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        if (!file.name.endsWith('.docx')) {
          notify('âŒ .docx íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤');
          e.target.value = '';
          return;
        }

        notify('ğŸ“„ íŒŒì¼ ì½ëŠ” ì¤‘...', 10000);

        try {
          notify('ğŸ“– íŒŒì¼ ë‚´ìš© ì¶”ì¶œ ì¤‘...', 10000);
          const arrayBuffer = await file.arrayBuffer();
          
          notify('âœï¸ í…ìŠ¤íŠ¸ ë³€í™˜ ì¤‘...', 10000);
          const result = await window.mammoth.extractRawText({ arrayBuffer });
          const text = result.value;

          if (!text || text.trim().length === 0) {
            notify('âŒ íŒŒì¼ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
            e.target.value = '';
            return;
          }

          notify('ğŸ” ë§ì”€ ë¶„ì„ ì¤‘...', 10000);
          const { updates, successCount, duplicates } = parseContent(text);
          
          if (duplicates.length > 0) {
            setVerses(prev => ({ ...prev, ...updates }));
            notify(`âš ï¸ ${successCount}ê°œ ì¶”ê°€, ${duplicates.length}ê°œ ì¤‘ë³µ ì œì™¸`, 3000);
            setTimeout(() => {
              setShowUploadModal(false);
            }, 3000);
          } else if (successCount > 0) {
            setVerses(prev => ({ ...prev, ...updates }));
            notify(`âœ… ${successCount}ê°œì˜ ë§ì”€ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤`, 2000);
            setTimeout(() => {
              setShowUploadModal(false);
            }, 2000);
          } else {
            notify('âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì˜ ë§ì”€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.', 3000);
          }
        } catch (error) {
          console.error('íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
          notify('âŒ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: ' + error.message, 5000);
        } finally {
          e.target.value = '';
        }
      };

      const handleBackup = () => {
        const backupData = {
          verses: verses,
          counts: counts,
          dailyHistory: dailyHistory,
          backupDate: new Date().toISOString()
        };
        const dataStr = JSON.stringify(backupData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ì„±ê²½ì•”ì†¡ì¹´ë“œ_ë°±ì—…_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        notify('âœ… ë°±ì—… íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤');
      };

      const handleRestore = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const backupData = JSON.parse(event.target.result);
            if (backupData.verses && backupData.counts) {
              setVerses(backupData.verses);
              setCounts(backupData.counts);
              if (backupData.dailyHistory) {
                setDailyHistory(backupData.dailyHistory);
              }
              notify('âœ… ë°ì´í„°ê°€ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤');
            } else {
              notify('âŒ ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤');
            }
          } catch (error) {
            notify('âŒ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ' + error.message);
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      };

      const searchVerses = () => {
        if (!searchQuery.trim()) return [];
        const query = searchQuery.toLowerCase();
        return Object.keys(verses).filter(key => {
          const verse = verses[key];
          return (
            verse.reference?.toLowerCase().includes(query) ||
            verse.text?.toLowerCase().includes(query) ||
            key.toLowerCase().includes(query)
          );
        });
      };

      const selectRandomCard = () => {
        const validCards = Object.keys(verses).filter(key => 
          verses[key].reference && verses[key].text
        );
        if (validCards.length === 0) {
          notify('âš ï¸ ë“±ë¡ëœ ë§ì”€ì´ ì—†ìŠµë‹ˆë‹¤');
          return;
        }
        const randomKey = validCards[Math.floor(Math.random() * validCards.length)];
        setQuizCard(randomKey);
        setShowQuizAnswer(false);
        setShowQuizMode(true);
      };

      const playCelebrationMelody = async (level) => {
        try {
          await Tone.start();
          const synth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: {
              attack: 0.005,
              decay: 0.1,
              sustain: 0.3,
              release: 0.8
            }
          }).toDestination();

          const now = Tone.now();
          
          const melodies = {
            1: [
              ['G4', 0], ['G4', 0.2], ['A4', 0.4], ['A4', 0.6],
              ['G4', 0.8], ['G4', 1.0], ['E4', 1.2]
            ],
            2: [
              ['C4', 0], ['C4', 0.3], ['G4', 0.6], ['G4', 0.9],
              ['A4', 1.2], ['A4', 1.5], ['G4', 1.8]
            ],
            3: [
              ['C4', 0], ['C4', 0.25], ['D4', 0.5], ['C4', 0.75],
              ['F4', 1.0], ['E4', 1.5]
            ],
            4: [
              ['C4', 0], ['E4', 0.15], ['G4', 0.3], ['C5', 0.45],
              ['G4', 0.6], ['C5', 0.75], ['E5', 0.9], ['C5', 1.05],
              ['G4', 1.2], ['C5', 1.4]
            ]
          };

          const melody = level <= 3 ? melodies[level] : melodies[4];
          
          melody.forEach(([note, time]) => {
            synth.triggerAttackRelease(note, '8n', now + time);
          });

        } catch (error) {
          console.log('ë©œë¡œë”” ì¬ìƒ ì‹¤íŒ¨:', error);
        }
      };

      const incrementCount = (cardKey) => {
        const today = new Date().toISOString().split('T')[0];
        const newCount = (counts[cardKey] || 0) + 1;
        
        setCounts(prev => ({...prev, [cardKey]: newCount}));
        setDailyHistory(prev => ({
          ...prev,
          [today]: {
            ...prev[today],
            [cardKey]: ((prev[today]?.[cardKey]) || 0) + 1
          }
        }));

        if (newCount > 0 && newCount % 10 === 0) {
          const messages = [
            'ğŸ‰ 10íšŒ ë‹¬ì„±! ì¢‹ì€ ì‹œì‘ì´ì—ìš”!',
            'ğŸŒŸ 20íšŒ ë‹¬ì„±! ì ì  ìµìˆ™í•´ì§€ê³  ìˆì–´ìš”!',
            'ğŸ’ª 30íšŒ ë‹¬ì„±! ê³„ì† ì´ ê¸°ì„¸ë¡œ!',
            'ğŸ”¥ 40íšŒ ë‹¬ì„±! ì •ë§ ëŒ€ë‹¨í•´ìš”!',
            'â­ 50íšŒ ë‹¬ì„±! ì ˆë°˜ì„ ë„˜ì—ˆì–´ìš”!',
            'ğŸŠ 60íšŒ ë‹¬ì„±! ê±°ì˜ ë‹¤ ì™”ì–´ìš”!',
            'ğŸ‘ 70íšŒ ë‹¬ì„±! ë†€ë¼ìš´ ì„±ê³¼ì˜ˆìš”!',
            'ğŸ† 80íšŒ ë‹¬ì„±! ìµœê³ ì˜ ì•”ì†¡ì™•!',
            'ğŸ’ 90íšŒ ë‹¬ì„±! ì™„ë²½ì— ê°€ê¹Œì›Œìš”!',
            'ğŸ‘‘ 100íšŒ ë‹¬ì„±! ì¶•í•˜í•©ë‹ˆë‹¤! ì™„ì „ ë§ˆìŠ¤í„°!'
          ];
          
          const messageIndex = Math.floor(newCount / 10) - 1;
          const message = messageIndex < messages.length 
            ? messages[messageIndex] 
            : `ğŸŒˆ ${newCount}íšŒ ë‹¬ì„±! ì •ë§ ëŒ€ë‹¨í•©ë‹ˆë‹¤!`;
          
          setEncouragementMsg(message);
          setTimeout(() => setEncouragementMsg(''), 7000);
          
          const melodyLevel = Math.min(Math.floor(newCount / 10), 4);
          playCelebrationMelody(melodyLevel);
        }
      };

      const getStats = () => {
        const totalCount = Object.values(counts).reduce((sum, count) => sum + count, 0);
        const activeCards = Object.values(counts).filter(c => c > 0).length;
        const verseCards = Object.keys(verses).filter(k => verses[k].reference && verses[k].text).length;
        
        const sortedCounts = Object.entries(counts)
          .filter(([key]) => verses[key]?.reference && verses[key]?.text)
          .sort((a, b) => b[1] - a[1]);
        
        const mostMemorized = sortedCounts.slice(0, 5);
        const leastMemorized = sortedCounts.filter(([_, count]) => count === 0 || count < 3).slice(0, 5);
        
        const last7Days = [];
        for (let i = 6; i >= 0; i--) {
          const date = new Date();
          date.setDate(date.getDate() - i);
          const dateStr = date.toISOString().split('T')[0];
          const dayTotal = dailyHistory[dateStr] 
            ? Object.values(dailyHistory[dateStr]).reduce((sum, count) => sum + count, 0)
            : 0;
          last7Days.push({ date: dateStr, count: dayTotal });
        }

        return { totalCount, activeCards, verseCards, mostMemorized, leastMemorized, last7Days };
      };

      const resetCounters = (type) => {
        if (type === 'all') {
          setCounts({});
          setDailyHistory({});
          notify('âœ… ì „ì²´ ì•”ì†¡ ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else if (type === '0') {
          const newCounts = {...counts};
          Object.keys(newCounts).forEach(key => {
            if (key.startsWith('0')) {
              delete newCounts[key];
            }
          });
          setCounts(newCounts);
          notify(`âœ… 0XX ê·¸ë£¹ ì•”ì†¡ ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤`);
        } else if (type.match(/^[A-E]$/)) {
          const newCounts = {...counts};
          Object.keys(newCounts).forEach(key => {
            if (key.startsWith(type)) {
              delete newCounts[key];
            }
          });
          setCounts(newCounts);
          notify(`âœ… ${type} ê·¸ë£¹ ì•”ì†¡ ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤`);
        }
        setShowResetCountModal(false);
      };

      const goToPrevious = () => {
        const keys = Object.keys(verses).sort();
        const currentIndex = keys.indexOf(selectedCard);
        if (currentIndex > 0) {
          setSelectedCard(keys[currentIndex - 1]);
        }
      };

      const goToNext = () => {
        const keys = Object.keys(verses).sort();
        const currentIndex = keys.indexOf(selectedCard);
        if (currentIndex < keys.length - 1) {
          setSelectedCard(keys[currentIndex + 1]);
        }
      };

      const handleAddCard = () => {
        if (!newCardNumber.trim()) {
          notify('âš ï¸ ì¹´ë“œ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }
        if (!newCardReference.trim()) {
          notify('âš ï¸ ì„±ê²½ êµ¬ì ˆì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }
        if (!newCardText.trim()) {
          notify('âš ï¸ ë³¸ë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }

        const cardKey = newCardNumber.toUpperCase().trim();
        
        if (verses[cardKey]) {
          notify(`âš ï¸ ${cardKey} ì¹´ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤`);
          return;
        }

        const existingCard = Object.entries(verses).find(([key, value]) => 
          value.reference === newCardReference.trim()
        );
        
        if (existingCard) {
          notify(`âš ï¸ ${newCardReference}ëŠ” ì´ë¯¸ ${existingCard[0]} ì¹´ë“œì— ìˆìŠµë‹ˆë‹¤`);
          return;
        }

        setVerses(prev => ({
          ...prev,
          [cardKey]: {
            reference: newCardReference.trim(),
            text: newCardText.trim()
          }
        }));

        notify(`âœ… ${cardKey} ì¹´ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤`);
        setSelectedCard(cardKey);
        setNewCardNumber('');
        setNewCardReference('');
        setNewCardText('');
        setShowAddModal(false);
      };

      const handleEditCard = () => {
        if (!editCardReference.trim()) {
          notify('âš ï¸ ì„±ê²½ êµ¬ì ˆì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }
        if (!editCardText.trim()) {
          notify('âš ï¸ ë³¸ë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”');
          return;
        }

        setVerses(prev => ({
          ...prev,
          [selectedCard]: {
            reference: editCardReference.trim(),
            text: editCardText.trim()
          }
        }));

        notify(`âœ… ${selectedCard} ì¹´ë“œê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤`);
        setShowEditModal(false);
      };

      const openEditModal = () => {
        setEditCardReference(currentCard.reference || '');
        setEditCardText(currentCard.text || '');
        setShowEditModal(true);
      };

      const handleDeleteCard = () => {
        const newVerses = {...verses};
        delete newVerses[selectedCard];
        setVerses(newVerses);
        
        const newCounts = {...counts};
        delete newCounts[selectedCard];
        setCounts(newCounts);
        
        const newDailyHistory = {...dailyHistory};
        Object.keys(newDailyHistory).forEach(date => {
          if (newDailyHistory[date][selectedCard]) {
            delete newDailyHistory[date][selectedCard];
          }
        });
        setDailyHistory(newDailyHistory);
        
        const remainingKeys = Object.keys(newVerses).sort();
        if (remainingKeys.length > 0) {
          setSelectedCard(remainingKeys[0]);
        }
        
        setShowDeleteConfirm(false);
        setShowDeleteMenu(false);
        notify(`âœ… ${selectedCard} ì¹´ë“œì™€ ì•”ì†¡ ê¸°ë¡ì´ ì™„ì „íˆ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤`);
      };

      const toggleCardSelection = (key) => {
        setSelectedForDelete(prev => 
          prev.includes(key) 
            ? prev.filter(k => k !== key)
            : [...prev, key]
        );
      };

      const selectAllCards = () => {
        const allKeys = Object.keys(verses).sort();
        setSelectedForDelete(allKeys);
      };

      const deselectAllCards = () => {
        setSelectedForDelete([]);
      };

      const handleDeleteSelectedCards = () => {
        if (selectedForDelete.length === 0) {
          notify('âš ï¸ ì‚­ì œí•  ì¹´ë“œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”');
          return;
        }

        const newVerses = {...verses};
        const newCounts = {...counts};
        const newDailyHistory = {...dailyHistory};
        
        selectedForDelete.forEach(key => {
          delete newVerses[key];
          delete newCounts[key];
          Object.keys(newDailyHistory).forEach(date => {
            if (newDailyHistory[date][key]) {
              delete newDailyHistory[date][key];
            }
          });
        });
        
        setVerses(newVerses);
        setCounts(newCounts);
        setDailyHistory(newDailyHistory);
        
        const remainingKeys = Object.keys(newVerses).sort();
        if (remainingKeys.length > 0) {
          setSelectedCard(remainingKeys[0]);
        } else {
          setSelectedCard('');
        }
        
        notify(`âœ… ${selectedForDelete.length}ê°œì˜ ì¹´ë“œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤`);
        setSelectedForDelete([]);
        setShowMultiDeleteModal(false);
        setShowDeleteMenu(false);
      };

      const getCharacter = (count) => {
        if (count === 0) return { emoji: 'ğŸ˜Š' };
        if (count < 10) return { emoji: 'ğŸ»' };
        if (count < 20) return { emoji: 'ğŸ±' };
        if (count < 30) return { emoji: 'ğŸ™' };
        if (count < 40) return { emoji: 'ğŸ¤' };
        if (count < 50) return { emoji: 'ğŸ°' };
        if (count < 60) return { emoji: 'ğŸ§' };
        if (count < 70) return { emoji: 'ğŸµ' };
        if (count < 80) return { emoji: 'ğŸ¶' };
        if (count < 90) return { emoji: 'ğŸ®' };
        return { emoji: 'ğŸ‘‘' };
      };

      const currentCard = verses[selectedCard] || { reference: '', text: '' };
      const keys = Object.keys(verses).sort();
      const currentIndex = keys.indexOf(selectedCard);
      const currentCount = counts[selectedCard] || 0;
      const searchResults = searchVerses();
      const stats = getStats();
      const currentCharacter = getCharacter(currentCount);

      if (isLoading) {
        return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-center">
              <div className="text-4xl mb-4">ğŸ“–</div>
              <div className="text-lg font-bold text-purple-700">ë°ì´í„° ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen" style={{ background: 'linear-gradient(180deg, #e8eaf6 0%, #f3e5f5 100%)' }}>
          {notification && (
            <div className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-white text-gray-800 px-6 py-3 rounded-xl font-bold text-sm shadow-2xl z-50">
              {notification}
            </div>
          )}

          <div className="max-w-md mx-auto p-4">
            <div className="bg-white shadow-lg p-4 mb-3 rounded-2xl">
              <h1 className="text-2xl font-black text-center mb-4 text-purple-700">ğŸ“– ì„±ê²½ ì•”ì†¡ ì¹´ë“œ ğŸ“–</h1>
              
              <div className="mb-3">
                <label className="flex items-center gap-2 text-sm font-bold text-gray-700 mb-2">
                  ğŸ“‡ ì•”ì†¡ ì¹´ë“œ ì„ íƒ
                </label>
                {keys.length > 0 ? (
                  <div className="flex gap-2 items-center">
                    <button
                      onClick={goToPrevious}
                      disabled={currentIndex === 0 || keys.length === 0}
                      className="px-1.5 py-1.5 bg-purple-500 text-white rounded-xl font-bold hover:bg-purple-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors text-xs"
                    >
                      â—€
                    </button>
                    <select 
                      value={selectedCard}
                      onChange={(e) => setSelectedCard(e.target.value)}
                      className="flex-1 px-2 py-1.5 border-2 border-purple-300 rounded-xl font-bold bg-white focus:border-purple-500 focus:outline-none"
                      style={{ fontSize: '15px' }}
                    >
                      {keys.map(key => {
                        const v = verses[key];
                        const hasContent = v && v.reference && v.text;
                        const displayText = hasContent 
                          ? `${key} - ${v.reference} âœ…` 
                          : `${key} âšª`;
                        return (
                          <option key={key} value={key} style={{ fontSize: '10px' }}>
                            {displayText}
                          </option>
                        );
                      })}
                    </select>
                    <button
                      onClick={goToNext}
                      disabled={currentIndex === keys.length - 1 || keys.length === 0}
                      className="px-1.5 py-1.5 bg-purple-500 text-white rounded-xl font-bold hover:bg-purple-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors text-xs"
                    >
                      â–¶
                    </button>
                  </div>
                ) : (
                  <div className="text-center py-8 bg-gray-50 rounded-xl border-2 border-dashed border-gray-300">
                    <p className="text-gray-400 font-bold mb-3">ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤</p>
                    <button
                      onClick={() => setShowAddModal(true)}
                      className="px-6 py-2 bg-purple-500 text-white rounded-lg font-bold hover:bg-purple-600"
                    >
                      ë§ì”€ ì¶”ê°€í•˜ê¸°
                    </button>
                  </div>
                )}
              </div>
            </div>

            {keys.length > 0 && (
              <>
                <div style={{ 
                  background: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                  padding: '5px',
                  borderRadius: '24px'
                }}>
                  <div className="bg-white rounded-3xl p-5 shadow-lg">
                    <div className="flex items-center justify-center mb-3">
                      <span style={{ fontSize: '20px', marginRight: '0.375rem' }}>ğŸ¶</span>
                      <div className="text-center flex-1">
                        <div className="flex items-center justify-center gap-2">
                          <span className="font-black text-green-600" style={{ fontSize: '18px' }}>{selectedCard}</span>
                          <span className="font-bold text-gray-400" style={{ fontSize: '18px' }}>-</span>
                          {currentCard.reference && (
                            <span className="font-black text-gray-900" style={{ fontSize: '20px', lineHeight: '1.3' }}>
                              {currentCard.reference}
                            </span>
                          )}
                        </div>
                      </div>
                      <span style={{ fontSize: '20px', marginLeft: '0.375rem' }}>ğŸ±</span>
                    </div>
                    {currentCard.reference && currentCard.text ? (
                      <div className="font-bold text-gray-800" style={{ fontSize: '20px', lineHeight: '1.5', wordBreak: 'keep-all' }}>
                        {currentCard.text}
                      </div>
                    ) : (
                      <div className="text-center py-8">
                        <p className="text-gray-400 font-bold text-base">ë§ì”€ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”</p>
                        <button 
                          onClick={() => setShowAddModal(true)}
                          className="mt-3 px-6 py-2 bg-purple-500 text-white rounded-lg font-bold text-sm"
                        >
                          ë§ì”€ ì¶”ê°€í•˜ê¸°
                        </button>
                      </div>
                    )}
                  </div>
                </div>

                <div className="mt-4 bg-white rounded-3xl p-6 shadow-lg">
                  <div className="flex items-start justify-between mb-2">
                    <button
                      onClick={() => setCounts(prev => ({...prev, [selectedCard]: 0}))}
                      className="px-3 py-1.5 bg-gray-300 text-gray-700 rounded-lg font-bold text-xs hover:bg-gray-400 transition-colors"
                    >
                      í˜„ì¬ ì´ˆê¸°í™”
                    </button>
                    <button
                      onClick={() => setShowResetCountModal(true)}
                      className="p-1.5 bg-gray-400 text-white rounded-lg font-bold hover:bg-gray-500 transition-colors"
                    >
                      <RotateCcw className="w-4 h-4" />
                    </button>
                  </div>
                  
                  <div className="flex items-center justify-center gap-4 mb-4">
                    <div className="text-7xl">{currentCharacter.emoji}</div>
                    <div className="text-8xl font-black text-purple-600">{currentCount}</div>
                  </div>
                  <p className="text-sm font-bold text-gray-500 text-center mb-4">ì•”ì†¡ íšŸìˆ˜</p>
                  
                  {encouragementMsg && (
                    <div className="mb-4 bg-gradient-to-r from-yellow-100 to-pink-100 rounded-xl p-3 text-center animate-pulse">
                      <p className="text-base font-black text-purple-700">{encouragementMsg}</p>
                    </div>
                  )}
                  
                  <div className="flex gap-5 justify-center">
                    <button
                      onClick={() => setCounts(prev => ({...prev, [selectedCard]: Math.max(0, (prev[selectedCard] || 0) - 1)}))}
                      className="w-20 py-2 bg-red-500 text-white rounded-xl font-black text-2xl hover:bg-red-600 transition-colors"
                    >
                      -1
                    </button>
                    <button
                      onClick={() => incrementCount(selectedCard)}
                      className="w-20 py-2 bg-green-500 text-white rounded-xl font-black text-2xl hover:bg-green-600 transition-colors"
                    >
                      +1
                    </button>
                  </div>
                </div>

                <div className="mt-4 bg-white rounded-3xl p-4 shadow-lg">
                  <div className="grid grid-cols-4 gap-2 mb-2">
                    <button
                      onClick={() => setShowAddModal(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-blue-500 to-blue-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <span className="text-lg mb-1">â•</span>
                      ê°œë³„ì¶”ê°€
                    </button>
                    <button
                      onClick={() => setShowUploadModal(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-indigo-500 to-indigo-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <Upload className="w-5 h-5 mb-1" />
                      ëŒ€ëŸ‰ì¶”ê°€
                    </button>
                    <button
                      onClick={openEditModal}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-amber-500 to-amber-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <span className="text-lg mb-1">âœï¸</span>
                      ìˆ˜ì •
                    </button>
                    <button
                      onClick={() => setShowSearchModal(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-teal-500 to-teal-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <Search className="w-5 h-5 mb-1" />
                      ê²€ìƒ‰
                    </button>
                  </div>

                  <div className="grid grid-cols-4 gap-2 mb-2">
                    <button
                      onClick={() => setShowAllVerses(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-green-500 to-green-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <span className="text-lg mb-1">ğŸ“–</span>
                      ë§ì”€ëª©ë¡
                    </button>
                    <button
                      onClick={selectRandomCard}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-pink-500 to-pink-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <Shuffle className="w-5 h-5 mb-1" />
                      í€´ì¦ˆ
                    </button>
                    <button
                      onClick={() => setShowAllCounts(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-purple-500 to-purple-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <span className="text-lg mb-1">ğŸ“Š</span>
                      ê¸°ë¡
                    </button>
                    <button
                      onClick={() => setShowStatsModal(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-orange-500 to-orange-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <BarChart3 className="w-5 h-5 mb-1" />
                      í†µê³„
                    </button>
                  </div>

                  <div className="grid grid-cols-2 gap-2">
                    <button
                      onClick={handleBackup}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-cyan-500 to-cyan-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <Download className="w-5 h-5 mb-1" />
                      ë°±ì—…
                    </button>
                    <button
                      onClick={() => setShowDeleteMenu(true)}
                      className="flex flex-col items-center justify-center p-3 bg-gradient-to-br from-red-500 to-red-600 text-white rounded-xl font-bold text-xs shadow-lg hover:shadow-xl transition-shadow"
                    >
                      <X className="w-5 h-5 mb-1" />
                      ì‚­ì œ
                    </button>
                  </div>
                </div>
              </>
            )}
          </div>

          {/* ëª¨ë‹¬ë“¤ì€ ë„ˆë¬´ ê¸¸ì–´ì„œ ìƒëµ... í•„ìš”ì‹œ ìš”ì²­í•´ì£¼ì„¸ìš” */}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<BibleMemoryCards />);
  </script>
</body>
</html>